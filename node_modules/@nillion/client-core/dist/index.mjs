// src/configs.ts
import { z as z2 } from "zod";

// src/types.ts
import { z } from "zod";
var TxHash = z.string().length(64).base64().brand();
var ActionId = z.string().uuid().brand();
var ChainId = z.string().min(1).brand();
var ClusterId = z.string().uuid().brand();
var ClusterDescriptor = z.object({
  id: ClusterId,
  kappa: z.number(),
  // TODO(tim): has rust type parties: HashSet<PartyId>
  // parties: z.array(z.unknown()),
  prime: z.string()
}).brand();
var ComputeOutputId = z.string().uuid().brand();
var Days = z.number().int().min(1).brand();
var NamedValue = z.string().min(1).brand();
var NilChainAddressPrefix = "nillion";
var NilChainAddress = z.string().length(46).startsWith(NilChainAddressPrefix).brand();
var NodeSeed = z.string().min(1).brand();
var OperationCost = z.object({
  base: z.number(),
  compute: z.number(),
  congestion: z.number(),
  preprocessing: z.number(),
  storage: z.number(),
  total: z.number()
}).brand();
var PartyName = z.string().min(1).brand();
var ProgramName = z.string().min(1).brand();
var PartyId = z.string().length(52).brand();
var PriceQuote = z.object({
  expires: z.date(),
  nonce: z.instanceof(Uint8Array),
  cost: OperationCost,
  inner: z.custom()
}).brand();
var ProgramId = z.string().min(1).brand();
var PaymentReceipt = z.object({
  quote: PriceQuote,
  hash: TxHash
}).brand();
var PrivateKeyBase16 = z.string().length(64).brand();
var UserId = z.string().min(87).max(89).brand();
var UserSeed = z.string().min(1).brand();
var Url = z.string().url().brand();
var multiaddrRegex = /^\/(ip4|ip6|dns4|dns6|dns)\/(.*?)\/tcp\/(.*?)\/(ws|wss|x-parity-ws\/(.*)|x-parity-wss\/(.*))(|\/p2p\/[a-zA-Z0-9]+)$/;
var Multiaddr = z.string().regex(multiaddrRegex).brand();
var StoreId = z.string().uuid().brand();
var Token = {
  Unil: "unil",
  asUnil: (amount) => `${String(amount)}${Token.Unil}`
};

// src/configs.ts
var NamedNetwork = z2.enum(["photon", "devnet"]);
var NamedNetworkConfig = {
  devnet: {
    clusterId: ClusterId.parse("9e68173f-9c23-4acc-ba81-4f079b639964"),
    bootnodes: [
      Multiaddr.parse(
        "/ip4/127.0.0.1/tcp/54936/ws/p2p/12D3KooWMvw1hEqm7EWSDEyqTb6pNetUVkepahKY6hixuAuMZfJS"
      )
    ],
    nilChainId: ChainId.parse("nillion-chain-devnet"),
    nilChainEndpoint: Url.parse("http://127.0.0.1:48102")
  },
  photon: {
    clusterId: ClusterId.parse("b13880d3-dde8-4a75-a171-8a1a9d985e6c"),
    bootnodes: [
      Multiaddr.parse(
        "/dns/node-1.testnet-photon.nillion-network.nilogy.xyz/tcp/14211/wss/p2p/12D3KooWCfFYAb77NCjEk711e9BVe2E6mrasPZTtAjJAPtVAdbye"
      )
    ],
    nilChainId: ChainId.parse("nillion-chain-testnet-1"),
    nilChainEndpoint: Url.parse(
      "https://rpc.testnet.nilchain-rpc-proxy.nilogy.xyz"
    )
  }
};

// src/error.ts
var isTaggedError = (e) => {
  return e instanceof Error && "_tag" in e;
};

// src/init.ts
import * as Wasm from "@nillion/client-wasm";

// src/logger.ts
import debug from "debug";
var Log = debug("nillion:core");
Log.log = console.log.bind(console);

// src/init.ts
var supportedEnvironmentGuard = () => {
  if (typeof globalThis.window === "undefined") {
    const message = "Init error: Only browser environments are supported.";
    Log(message);
    throw new Error(message);
  }
  return true;
};
var dedupInitGuard = () => {
  const wasInitialised = Boolean(globalThis.__NILLION?.initialized);
  if (wasInitialised) {
    Log("Init warning: Nillion init called more than once.");
  }
  return wasInitialised;
};
async function init() {
  supportedEnvironmentGuard();
  if (dedupInitGuard()) {
    Log("Already initialised. Noop.");
    return;
  }
  const result = await Wasm.default();
  result.__wbindgen_start();
  globalThis.__NILLION = {
    initialized: true,
    disableLogging: () => {
      Log(`Disabling logging.`);
      localStorage.debug = "";
    },
    enableLogging: () => {
      localStorage.debug = "nillion:*";
      Log(`Logging namespaces: ${localStorage.debug}.`);
    },
    enableWasmLogging: () => {
      Wasm.NillionClient.enable_remote_logging();
      Log("Remote logging initialised.");
    },
    enableTelemetry: (addr) => {
      Wasm.NillionClient.enable_tracking(addr);
      Log("Telemetry reported enabled.");
    }
  };
  Log("Wasm initialized.");
}

// src/nada/program.ts
import * as Wasm2 from "@nillion/client-wasm";
var ProgramBindings2 = class _ProgramBindings {
  constructor(id, inputs = /* @__PURE__ */ new Map(), outputs = /* @__PURE__ */ new Map()) {
    this.id = id;
    this.inputs = inputs;
    this.outputs = outputs;
  }
  addInputParty(name, id) {
    Log(`add input party name=${name} with id=${id}`);
    if (this.inputs.has(name)) {
      Log(`input party exists, overwriting`);
    }
    this.inputs.set(name, id);
    return this;
  }
  addOutputParty(name, id) {
    Log(`add output party name=${name} with id=${id}`);
    if (this.outputs.has(name)) {
      Log(`output party exists, overwriting`);
    }
    this.outputs.set(name, id);
    return this;
  }
  into() {
    if (this.inputs.size === 0 && this.outputs.size === 0) {
      Log("program has no inputs our outputs");
    }
    const program = new Wasm2.ProgramBindings(this.id);
    for (const [name, id] of this.inputs) {
      program.add_input_party(name, id);
    }
    for (const [name, id] of this.outputs) {
      program.add_output_party(name, id);
    }
    return program;
  }
  toString() {
    return `ProgramBindings(id=${this.id})`;
  }
  static create(id) {
    const parsed = ProgramId.parse(id);
    return new _ProgramBindings(parsed);
  }
};

// src/nada/store-acl.ts
import * as Wasm3 from "@nillion/client-wasm";
var StoreAcl = class _StoreAcl {
  constructor(computeAllowed = /* @__PURE__ */ new Map(), deleteAllowed = /* @__PURE__ */ new Set(), retrieveAllowed = /* @__PURE__ */ new Set(), updateAllowed = /* @__PURE__ */ new Set()) {
    this.computeAllowed = computeAllowed;
    this.deleteAllowed = deleteAllowed;
    this.retrieveAllowed = retrieveAllowed;
    this.updateAllowed = updateAllowed;
  }
  allowCompute(users, program) {
    const listOfUsers = Array.isArray(users) ? users : [users];
    for (const user of listOfUsers) {
      const programs = this.computeAllowed.get(user) ?? /* @__PURE__ */ new Set();
      programs.add(program);
      this.computeAllowed.set(user, programs);
    }
    return this;
  }
  allowDelete(users) {
    if (Array.isArray(users)) {
      users.forEach((u) => this.deleteAllowed.add(u));
    } else {
      this.deleteAllowed.add(users);
    }
    return this;
  }
  allowRetrieve(users) {
    if (Array.isArray(users)) {
      users.forEach((u) => this.retrieveAllowed.add(u));
    } else {
      this.retrieveAllowed.add(users);
    }
    return this;
  }
  allowUpdate(users) {
    if (Array.isArray(users)) {
      users.forEach((u) => this.updateAllowed.add(u));
    } else {
      this.updateAllowed.add(users);
    }
    return this;
  }
  getPermissionsByUser(user) {
    return {
      user,
      compute: this.computeAllowed.has(user),
      delete: this.deleteAllowed.has(user),
      retrieve: this.retrieveAllowed.has(user),
      update: this.updateAllowed.has(user)
    };
  }
  isComputeAllowed(user, program) {
    const permissions = this.computeAllowed.get(user);
    return permissions ? permissions.has(program) : false;
  }
  isDeleteAllowed(user) {
    return this.deleteAllowed.has(user);
  }
  isRetrieveAllowed(user) {
    return this.retrieveAllowed.has(user);
  }
  isUpdateAllowed(user) {
    return this.updateAllowed.has(user);
  }
  into() {
    const wasm = new Wasm3.Permissions();
    wasm.add_update_permissions(Array.from(this.updateAllowed));
    wasm.add_delete_permissions(Array.from(this.deleteAllowed));
    wasm.add_retrieve_permissions(Array.from(this.retrieveAllowed));
    const computeAcl = /* @__PURE__ */ new Map();
    this.computeAllowed.forEach((programs, user) => {
      computeAcl.set(user, Array.from(programs));
    });
    wasm.add_compute_permissions(computeAcl);
    return wasm;
  }
  static from(_wasm) {
    Log("Converting Wasm.Permissions into StoreAcl is not yet supported.");
    return _StoreAcl.create();
  }
  static create() {
    return new _StoreAcl();
  }
  static createDefaultForUser(user) {
    return new _StoreAcl().allowRetrieve(user).allowUpdate(user).allowDelete(user);
  }
};

// src/nada/value.ts
import { z as z3 } from "zod";
import * as Wasm4 from "@nillion/client-wasm";

// src/type-guards.ts
var isMap = (value) => {
  return isDefinedAndNotNull(value) && value instanceof Map;
};
var isObjectLiteral = (value) => {
  return isDefinedAndNotNull(value) && value?.constructor === Object;
};
var isUint8Array = (value) => {
  return isDefinedAndNotNull(value) && value instanceof Uint8Array;
};
var isBigInt = (value) => {
  return isDefinedAndNotNull(value) && typeof value === "bigint";
};
var isNumber = (value) => {
  return isDefinedAndNotNull(value) && typeof value === "number";
};
var isBoolean = (value) => {
  return isDefinedAndNotNull(value) && typeof value === "boolean";
};
var isString = (value) => {
  return isDefinedAndNotNull(value) && typeof value === "string";
};
var isNull = (value) => {
  return value === null;
};
var isUndefined = (value) => {
  return value === void 0;
};
var isDefinedAndNotNull = (value) => {
  return value !== void 0 && value !== null;
};

// src/nada/value.ts
var NadaValueType = z3.enum([
  "SecretString",
  // not a native nada type but provided for improved DX
  "SecretBlob",
  "SecretBoolean",
  "PublicInteger",
  "PublicIntegerUnsigned",
  "SecretInteger",
  "SecretIntegerUnsigned"
]);
var SecretString = z3.string().brand();
var SecretBlob = z3.instanceof(Uint8Array).brand();
var SecretBoolean = z3.boolean().brand();
var PublicInteger = z3.number().int().brand();
var PublicIntegerUnsigned = z3.bigint().nonnegative().brand();
var SecretInteger = z3.number().int().brand();
var SecretIntegerUnsigned = z3.bigint().nonnegative().brand();
var NadaValue2 = class _NadaValue {
  constructor(type, data) {
    this.type = type;
    this.data = data;
  }
  toString() {
    return `NadaValue(type=${this.type})`;
  }
  toWasm() {
    switch (this.type) {
      case NadaValueType.enum.SecretString: {
        const data = new TextEncoder().encode(this.data);
        return Wasm4.NadaValue.new_secret_blob(data);
      }
      case NadaValueType.enum.SecretBlob: {
        return Wasm4.NadaValue.new_secret_blob(this.data);
      }
      case NadaValueType.enum.SecretBoolean: {
        throw new Error(
          "return Wasm.NadaValue.new_secret_boolean(this.data as boolean);"
        );
      }
      case NadaValueType.enum.PublicInteger: {
        return Wasm4.NadaValue.new_public_integer(String(this.data));
      }
      case NadaValueType.enum.PublicIntegerUnsigned: {
        return Wasm4.NadaValue.new_public_unsigned_integer(String(this.data));
      }
      case NadaValueType.enum.SecretInteger: {
        return Wasm4.NadaValue.new_secret_integer(String(this.data));
      }
      case NadaValueType.enum.SecretIntegerUnsigned: {
        return Wasm4.NadaValue.new_secret_unsigned_integer(String(this.data));
      }
    }
  }
  static fromWasm(type, wasm) {
    switch (type) {
      case NadaValueType.enum.SecretString: {
        const copiedFromMemory = Array.from(wasm.to_byte_array());
        const values = Uint8Array.from(copiedFromMemory);
        const data = new TextDecoder().decode(values);
        return _NadaValue.createSecretString(data);
      }
      case NadaValueType.enum.SecretBlob: {
        const copiedFromMemory = Array.from(wasm.to_byte_array());
        const values = Uint8Array.from(copiedFromMemory);
        return _NadaValue.createSecretBlob(values);
      }
      case NadaValueType.enum.SecretBoolean: {
        throw new Error("return NadaValue.createSecretBoolean(wasm.xyz())");
      }
      case NadaValueType.enum.PublicInteger: {
        const data = wasm.to_integer();
        return _NadaValue.createPublicInteger(Number(data));
      }
      case NadaValueType.enum.PublicIntegerUnsigned: {
        const data = wasm.to_integer();
        return _NadaValue.createPublicIntegerUnsigned(BigInt(data));
      }
      case NadaValueType.enum.SecretInteger: {
        const data = wasm.to_integer();
        return _NadaValue.createSecretInteger(Number(data));
      }
      case NadaValueType.enum.SecretIntegerUnsigned: {
        const data = wasm.to_integer();
        return _NadaValue.createSecretIntegerUnsigned(BigInt(data));
      }
    }
  }
  static fromPrimitive(args) {
    const { secret } = args;
    let data = args.data;
    if (typeof data === "string") {
      data = new TextEncoder().encode(data);
    }
    if (isUint8Array(data)) {
      if (!secret) {
        Log("NadaValue.fromPrimitive data: Uint8Array is always secret");
      }
      return this.createSecretBlob(data);
    } else if (isBigInt(data)) {
      return secret ? this.createSecretIntegerUnsigned(data) : this.createPublicIntegerUnsigned(data);
    } else if (isNumber(data)) {
      return secret ? this.createSecretInteger(data) : this.createPublicInteger(data);
    } else {
      throw new Error(
        "Invalid NadaValue.fromPrimitive() arguments: " + JSON.stringify(args)
      );
    }
  }
  static createSecretString(data) {
    return new _NadaValue(
      NadaValueType.enum.SecretString,
      SecretString.parse(data)
    );
  }
  static createSecretBlob(data) {
    return new _NadaValue(NadaValueType.enum.SecretBlob, SecretBlob.parse(data));
  }
  static createPublicInteger(data) {
    return new _NadaValue(
      NadaValueType.enum.PublicInteger,
      PublicInteger.parse(data)
    );
  }
  static createSecretInteger(data) {
    return new _NadaValue(
      NadaValueType.enum.SecretInteger,
      SecretInteger.parse(data)
    );
  }
  static createPublicIntegerUnsigned(data) {
    return new _NadaValue(
      NadaValueType.enum.PublicIntegerUnsigned,
      PublicIntegerUnsigned.parse(data)
    );
  }
  static createSecretIntegerUnsigned(data) {
    return new _NadaValue(
      NadaValueType.enum.SecretIntegerUnsigned,
      SecretIntegerUnsigned.parse(data)
    );
  }
};

// src/nada/values.ts
import * as Wasm5 from "@nillion/client-wasm";
var NadaValues2 = class _NadaValues {
  constructor(values = /* @__PURE__ */ new Map()) {
    this.values = values;
  }
  get length() {
    return this.values.size;
  }
  insert(name, value) {
    Log(`Inserting into NadaValues ${name}=`, value);
    if (this.values.get(name)) {
      Log(`Insertion overwrote: ${name}`);
    }
    this.values.set(name, value);
    return this;
  }
  toString() {
    const values = Array.from(this.values);
    const stringified = values.map(([key, value]) => `${key}=${value.toString()}`).join(",");
    return `NadaValues([${stringified}])`;
  }
  into() {
    const wasmValues = new Wasm5.NadaValues();
    for (const [key, value] of this.values) {
      const wasmValue = value.toWasm();
      wasmValues.insert(key, wasmValue);
    }
    return wasmValues;
  }
  static create() {
    return new _NadaValues();
  }
};

// src/operation/compute.ts
import * as Wasm9 from "@nillion/client-wasm";

// src/operation/operation.ts
import { z as z4 } from "zod";

// src/operation/program.ts
import * as Wasm6 from "@nillion/client-wasm";
var StoreProgram = class {
  constructor(args) {
    this.args = args;
  }
  type = OperationType.enum.StoreProgram;
  intoQuotable() {
    return Wasm6.Operation.store_program(this.args.program);
  }
  toString() {
    return `Operation(type="StoreProgram")`;
  }
};

// src/operation/store-acl.ts
import * as Wasm7 from "@nillion/client-wasm";
var SetStoreAcl = class {
  constructor(args) {
    this.args = args;
  }
  type = OperationType.enum.SetStoreAcl;
  intoQuotable() {
    return Wasm7.Operation.update_permissions();
  }
  toString() {
    return `Operation(type="SetStoreAcl")`;
  }
};
var FetchStoreAcl = class {
  constructor(args) {
    this.args = args;
  }
  type = OperationType.enum.FetchStoreAcl;
  intoQuotable() {
    return Wasm7.Operation.retrieve_permissions();
  }
  toString() {
    return `Operation(type="FetchStoreAcl")`;
  }
};

// src/operation/values.ts
import * as Wasm8 from "@nillion/client-wasm";
var FetchValue = class {
  constructor(args) {
    this.args = args;
  }
  type = OperationType.enum.FetchValue;
  intoQuotable() {
    return Wasm8.Operation.retrieve_value();
  }
  toString() {
    return `Operation(type="FetchValue")`;
  }
};
var DeleteValue = class {
  constructor(args) {
    this.args = args;
  }
  type = OperationType.enum.DeleteValue;
  toString() {
    return `Operation(type="DeleteValue")`;
  }
};
var StoreValue = class {
  constructor(args) {
    this.args = args;
  }
  type = OperationType.enum.StoreValue;
  intoQuotable() {
    return Wasm8.Operation.store_values(this.args.values.into(), this.args.ttl);
  }
  toString() {
    return `Operation(type="StoreValue")`;
  }
};
var UpdateValue = class {
  constructor(args) {
    this.args = args;
  }
  type = OperationType.enum.UpdateValue;
  intoQuotable() {
    return Wasm8.Operation.update_values(this.args.values.into(), this.args.ttl);
  }
  toString() {
    return `Operation(type="UpdateValue")`;
  }
};

// src/operation/operation.ts
var OperationType = z4.enum([
  "StoreProgram",
  "Compute",
  "FetchComputeOutput",
  "StoreValue",
  "FetchValue",
  "UpdateValue",
  "DeleteValue",
  "FetchStoreAcl",
  "SetStoreAcl"
]);
var Operation7 = {
  storeProgram: (args) => new StoreProgram(args),
  compute: (args) => new Compute(args),
  fetchComputeOutput: (args) => new FetchComputeOutput(args),
  storeValues: (args) => new StoreValue(args),
  fetchValue: (args) => new FetchValue(args),
  updateValues: (args) => new UpdateValue(args),
  deleteValues: (args) => new DeleteValue(args),
  fetchAcl: (args) => new FetchStoreAcl(args),
  setAcl: (args) => new SetStoreAcl(args)
};

// src/operation/compute.ts
var Compute = class {
  constructor(args) {
    this.args = args;
  }
  type = OperationType.enum.Compute;
  intoQuotable() {
    return Wasm9.Operation.compute(
      this.args.bindings.id,
      this.args.values.into()
    );
  }
  toString() {
    return `Operation(type="Compute")`;
  }
};
var FetchComputeOutput = class {
  constructor(args) {
    this.args = args;
  }
  type = OperationType.enum.FetchComputeOutput;
  toString() {
    return `Operation(type="FetchComputeOutput")`;
  }
};

// src/result.ts
import { Effect as E, pipe } from "effect";
import { ZodError } from "zod";
var effectToResultAsync = (effect) => {
  return pipe(
    effect,
    E.match({
      onSuccess: (ok) => ({ ok, err: null }),
      onFailure: (err) => unwindError(err)
    }),
    E.runPromise
  );
};
var effectToResultSync = (effect) => {
  return pipe(
    effect,
    E.match({
      onSuccess: (ok) => ({ ok, err: null }),
      onFailure: (err) => unwindError(err)
    }),
    E.runSync
  );
};
var unwindError = (err) => {
  if (isTaggedError(err)) {
    const root = findRootErrorCause(err);
    if (root instanceof ZodError) {
      console.error("Operation failed with parsing error:", root.message);
      console.error("Stack trace: ", root.stack);
    } else {
      console.error("Operation failed with root error: ", root.message);
      console.error("Stack trace: ", root.stack);
    }
    return { err: root, ok: null };
  }
  console.error(err);
  throw err;
};
var findRootErrorCause = (err) => {
  const { cause } = err;
  if (!(cause instanceof Error)) {
    return err;
  } else {
    return findRootErrorCause(cause);
  }
};

// src/wasm.ts
import * as Wasm10 from "@nillion/client-wasm";
var priceQuoteFrom = (wasm) => {
  return PriceQuote.parse({
    expires: wasm.expires_at,
    nonce: wasm.nonce,
    cost: OperationCost.parse({
      base: Number(wasm.cost.base_fee),
      compute: Number(wasm.cost.compute_fee),
      congestion: Number(wasm.cost.congestion_fee),
      preprocessing: Number(wasm.cost.preprocessing_fee),
      storage: Number(wasm.cost.storage_fee),
      total: Number(wasm.cost.total)
    }),
    inner: wasm
  });
};
var priceQuoteInto = (quote) => quote.inner;
var paymentReceiptInto = (receipt) => new Wasm10.PaymentReceipt(receipt.quote.inner, receipt.hash);
export {
  ActionId,
  ChainId,
  ClusterDescriptor,
  ClusterId,
  Compute,
  ComputeOutputId,
  Days,
  DeleteValue,
  FetchComputeOutput,
  FetchStoreAcl,
  FetchValue,
  Multiaddr,
  NadaValue2 as NadaValue,
  NadaValueType,
  NadaValues2 as NadaValues,
  NamedNetwork,
  NamedNetworkConfig,
  NamedValue,
  NilChainAddress,
  NilChainAddressPrefix,
  NodeSeed,
  Operation7 as Operation,
  OperationCost,
  OperationType,
  PartyId,
  PartyName,
  PaymentReceipt,
  PriceQuote,
  PrivateKeyBase16,
  ProgramBindings2 as ProgramBindings,
  ProgramId,
  ProgramName,
  PublicInteger,
  PublicIntegerUnsigned,
  SecretBlob,
  SecretBoolean,
  SecretInteger,
  SecretIntegerUnsigned,
  SecretString,
  SetStoreAcl,
  StoreAcl,
  StoreId,
  StoreProgram,
  StoreValue,
  Token,
  TxHash,
  UpdateValue,
  Url,
  UserId,
  UserSeed,
  effectToResultAsync,
  effectToResultSync,
  init,
  isBigInt,
  isBoolean,
  isDefinedAndNotNull,
  isMap,
  isNull,
  isNumber,
  isObjectLiteral,
  isString,
  isTaggedError,
  isUint8Array,
  isUndefined,
  paymentReceiptInto,
  priceQuoteFrom,
  priceQuoteInto
};
