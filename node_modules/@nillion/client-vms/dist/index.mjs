// src/client.ts
import { Effect as E5, pipe as pipe2 } from "effect";
import { UnknownException } from "effect/Cause";
import { ZodError as ZodError2 } from "zod";

// ../client-core/src/configs.ts
import { z as z2 } from "zod";

// ../client-core/src/types.ts
import { z } from "zod";
var TxHash = z.string().length(64).base64().brand();
var ActionId = z.string().uuid().brand();
var ChainId = z.string().min(1).brand();
var ClusterId = z.string().uuid().brand();
var ClusterDescriptor = z.object({
  id: ClusterId,
  kappa: z.number(),
  // TODO(tim): has rust type parties: HashSet<PartyId>
  // parties: z.array(z.unknown()),
  prime: z.string()
}).brand();
var ComputeOutputId = z.string().uuid().brand();
var Days = z.number().int().min(1).brand();
var NamedValue = z.string().min(1).brand();
var NilChainAddressPrefix = "nillion";
var NilChainAddress = z.string().length(46).startsWith(NilChainAddressPrefix).brand();
var NodeSeed = z.string().min(1).brand();
var OperationCost = z.object({
  base: z.number(),
  compute: z.number(),
  congestion: z.number(),
  preprocessing: z.number(),
  storage: z.number(),
  total: z.number()
}).brand();
var PartyName = z.string().min(1).brand();
var ProgramName = z.string().min(1).brand();
var PartyId = z.string().length(52).brand();
var PriceQuote = z.object({
  expires: z.date(),
  nonce: z.instanceof(Uint8Array),
  cost: OperationCost,
  inner: z.custom()
}).brand();
var ProgramId = z.string().min(1).brand();
var PaymentReceipt = z.object({
  quote: PriceQuote,
  hash: TxHash
}).brand();
var PrivateKeyBase16 = z.string().length(64).brand();
var UserId = z.string().min(87).max(89).brand();
var UserSeed = z.string().min(1).brand();
var Url = z.string().url().brand();
var multiaddrRegex = /^\/(ip4|ip6|dns4|dns6|dns)\/(.*?)\/tcp\/(.*?)\/(ws|wss|x-parity-ws\/(.*)|x-parity-wss\/(.*))(|\/p2p\/[a-zA-Z0-9]+)$/;
var Multiaddr = z.string().regex(multiaddrRegex).brand();
var StoreId = z.string().uuid().brand();
var Token = {
  Unil: "unil",
  asUnil: (amount) => `${String(amount)}${Token.Unil}`
};

// ../client-core/src/configs.ts
var NamedNetwork = z2.enum(["photon", "devnet"]);
var NamedNetworkConfig = {
  devnet: {
    clusterId: ClusterId.parse("9e68173f-9c23-4acc-ba81-4f079b639964"),
    bootnodes: [
      Multiaddr.parse(
        "/ip4/127.0.0.1/tcp/54936/ws/p2p/12D3KooWMvw1hEqm7EWSDEyqTb6pNetUVkepahKY6hixuAuMZfJS"
      )
    ],
    nilChainId: ChainId.parse("nillion-chain-devnet"),
    nilChainEndpoint: Url.parse("http://127.0.0.1:48102")
  },
  photon: {
    clusterId: ClusterId.parse("b13880d3-dde8-4a75-a171-8a1a9d985e6c"),
    bootnodes: [
      Multiaddr.parse(
        "/dns/node-1.testnet-photon.nillion-network.nilogy.xyz/tcp/14211/wss/p2p/12D3KooWCfFYAb77NCjEk711e9BVe2E6mrasPZTtAjJAPtVAdbye"
      )
    ],
    nilChainId: ChainId.parse("nillion-chain-testnet-1"),
    nilChainEndpoint: Url.parse(
      "https://rpc.testnet.nilchain-rpc-proxy.nilogy.xyz"
    )
  }
};

// ../client-core/src/error.ts
var isTaggedError = (e) => {
  return e instanceof Error && "_tag" in e;
};

// ../client-core/src/init.ts
import * as Wasm from "@nillion/client-wasm";

// ../client-core/src/logger.ts
import debug from "debug";
var Log = debug("nillion:core");
Log.log = console.log.bind(console);

// ../client-core/src/init.ts
var supportedEnvironmentGuard = () => {
  if (typeof globalThis.window === "undefined") {
    const message = "Init error: Only browser environments are supported.";
    Log(message);
    throw new Error(message);
  }
  return true;
};
var dedupInitGuard = () => {
  const wasInitialised = Boolean(globalThis.__NILLION?.initialized);
  if (wasInitialised) {
    Log("Init warning: Nillion init called more than once.");
  }
  return wasInitialised;
};
async function init() {
  supportedEnvironmentGuard();
  if (dedupInitGuard()) {
    Log("Already initialised. Noop.");
    return;
  }
  const result = await Wasm.default();
  result.__wbindgen_start();
  globalThis.__NILLION = {
    initialized: true,
    disableLogging: () => {
      Log(`Disabling logging.`);
      localStorage.debug = "";
    },
    enableLogging: () => {
      localStorage.debug = "nillion:*";
      Log(`Logging namespaces: ${localStorage.debug}.`);
    },
    enableWasmLogging: () => {
      Wasm.NillionClient.enable_remote_logging();
      Log("Remote logging initialised.");
    },
    enableTelemetry: (addr) => {
      Wasm.NillionClient.enable_tracking(addr);
      Log("Telemetry reported enabled.");
    }
  };
  Log("Wasm initialized.");
}

// ../client-core/src/nada/program.ts
import * as Wasm2 from "@nillion/client-wasm";

// ../client-core/src/nada/store-acl.ts
import * as Wasm3 from "@nillion/client-wasm";
var StoreAcl = class _StoreAcl {
  constructor(computeAllowed = /* @__PURE__ */ new Map(), deleteAllowed = /* @__PURE__ */ new Set(), retrieveAllowed = /* @__PURE__ */ new Set(), updateAllowed = /* @__PURE__ */ new Set()) {
    this.computeAllowed = computeAllowed;
    this.deleteAllowed = deleteAllowed;
    this.retrieveAllowed = retrieveAllowed;
    this.updateAllowed = updateAllowed;
  }
  allowCompute(users, program) {
    const listOfUsers = Array.isArray(users) ? users : [users];
    for (const user of listOfUsers) {
      const programs = this.computeAllowed.get(user) ?? /* @__PURE__ */ new Set();
      programs.add(program);
      this.computeAllowed.set(user, programs);
    }
    return this;
  }
  allowDelete(users) {
    if (Array.isArray(users)) {
      users.forEach((u) => this.deleteAllowed.add(u));
    } else {
      this.deleteAllowed.add(users);
    }
    return this;
  }
  allowRetrieve(users) {
    if (Array.isArray(users)) {
      users.forEach((u) => this.retrieveAllowed.add(u));
    } else {
      this.retrieveAllowed.add(users);
    }
    return this;
  }
  allowUpdate(users) {
    if (Array.isArray(users)) {
      users.forEach((u) => this.updateAllowed.add(u));
    } else {
      this.updateAllowed.add(users);
    }
    return this;
  }
  getPermissionsByUser(user) {
    return {
      user,
      compute: this.computeAllowed.has(user),
      delete: this.deleteAllowed.has(user),
      retrieve: this.retrieveAllowed.has(user),
      update: this.updateAllowed.has(user)
    };
  }
  isComputeAllowed(user, program) {
    const permissions = this.computeAllowed.get(user);
    return permissions ? permissions.has(program) : false;
  }
  isDeleteAllowed(user) {
    return this.deleteAllowed.has(user);
  }
  isRetrieveAllowed(user) {
    return this.retrieveAllowed.has(user);
  }
  isUpdateAllowed(user) {
    return this.updateAllowed.has(user);
  }
  into() {
    const wasm = new Wasm3.Permissions();
    wasm.add_update_permissions(Array.from(this.updateAllowed));
    wasm.add_delete_permissions(Array.from(this.deleteAllowed));
    wasm.add_retrieve_permissions(Array.from(this.retrieveAllowed));
    const computeAcl = /* @__PURE__ */ new Map();
    this.computeAllowed.forEach((programs, user) => {
      computeAcl.set(user, Array.from(programs));
    });
    wasm.add_compute_permissions(computeAcl);
    return wasm;
  }
  static from(_wasm) {
    Log("Converting Wasm.Permissions into StoreAcl is not yet supported.");
    return _StoreAcl.create();
  }
  static create() {
    return new _StoreAcl();
  }
  static createDefaultForUser(user) {
    return new _StoreAcl().allowRetrieve(user).allowUpdate(user).allowDelete(user);
  }
};

// ../client-core/src/nada/value.ts
import { z as z3 } from "zod";
import * as Wasm4 from "@nillion/client-wasm";

// ../client-core/src/type-guards.ts
var isObjectLiteral = (value) => {
  return isDefinedAndNotNull(value) && value?.constructor === Object;
};
var isUint8Array = (value) => {
  return isDefinedAndNotNull(value) && value instanceof Uint8Array;
};
var isBigInt = (value) => {
  return isDefinedAndNotNull(value) && typeof value === "bigint";
};
var isNumber = (value) => {
  return isDefinedAndNotNull(value) && typeof value === "number";
};
var isDefinedAndNotNull = (value) => {
  return value !== void 0 && value !== null;
};

// ../client-core/src/nada/value.ts
var NadaValueType = z3.enum([
  "SecretString",
  // not a native nada type but provided for improved DX
  "SecretBlob",
  "SecretBoolean",
  "PublicInteger",
  "PublicIntegerUnsigned",
  "SecretInteger",
  "SecretIntegerUnsigned"
]);
var SecretString = z3.string().brand();
var SecretBlob = z3.instanceof(Uint8Array).brand();
var SecretBoolean = z3.boolean().brand();
var PublicInteger = z3.number().int().brand();
var PublicIntegerUnsigned = z3.bigint().nonnegative().brand();
var SecretInteger = z3.number().int().brand();
var SecretIntegerUnsigned = z3.bigint().nonnegative().brand();
var NadaValue2 = class _NadaValue {
  constructor(type, data) {
    this.type = type;
    this.data = data;
  }
  toString() {
    return `NadaValue(type=${this.type})`;
  }
  toWasm() {
    switch (this.type) {
      case NadaValueType.enum.SecretString: {
        const data = new TextEncoder().encode(this.data);
        return Wasm4.NadaValue.new_secret_blob(data);
      }
      case NadaValueType.enum.SecretBlob: {
        return Wasm4.NadaValue.new_secret_blob(this.data);
      }
      case NadaValueType.enum.SecretBoolean: {
        throw new Error(
          "return Wasm.NadaValue.new_secret_boolean(this.data as boolean);"
        );
      }
      case NadaValueType.enum.PublicInteger: {
        return Wasm4.NadaValue.new_public_integer(String(this.data));
      }
      case NadaValueType.enum.PublicIntegerUnsigned: {
        return Wasm4.NadaValue.new_public_unsigned_integer(String(this.data));
      }
      case NadaValueType.enum.SecretInteger: {
        return Wasm4.NadaValue.new_secret_integer(String(this.data));
      }
      case NadaValueType.enum.SecretIntegerUnsigned: {
        return Wasm4.NadaValue.new_secret_unsigned_integer(String(this.data));
      }
    }
  }
  static fromWasm(type, wasm) {
    switch (type) {
      case NadaValueType.enum.SecretString: {
        const copiedFromMemory = Array.from(wasm.to_byte_array());
        const values = Uint8Array.from(copiedFromMemory);
        const data = new TextDecoder().decode(values);
        return _NadaValue.createSecretString(data);
      }
      case NadaValueType.enum.SecretBlob: {
        const copiedFromMemory = Array.from(wasm.to_byte_array());
        const values = Uint8Array.from(copiedFromMemory);
        return _NadaValue.createSecretBlob(values);
      }
      case NadaValueType.enum.SecretBoolean: {
        throw new Error("return NadaValue.createSecretBoolean(wasm.xyz())");
      }
      case NadaValueType.enum.PublicInteger: {
        const data = wasm.to_integer();
        return _NadaValue.createPublicInteger(Number(data));
      }
      case NadaValueType.enum.PublicIntegerUnsigned: {
        const data = wasm.to_integer();
        return _NadaValue.createPublicIntegerUnsigned(BigInt(data));
      }
      case NadaValueType.enum.SecretInteger: {
        const data = wasm.to_integer();
        return _NadaValue.createSecretInteger(Number(data));
      }
      case NadaValueType.enum.SecretIntegerUnsigned: {
        const data = wasm.to_integer();
        return _NadaValue.createSecretIntegerUnsigned(BigInt(data));
      }
    }
  }
  static fromPrimitive(args) {
    const { secret } = args;
    let data = args.data;
    if (typeof data === "string") {
      data = new TextEncoder().encode(data);
    }
    if (isUint8Array(data)) {
      if (!secret) {
        Log("NadaValue.fromPrimitive data: Uint8Array is always secret");
      }
      return this.createSecretBlob(data);
    } else if (isBigInt(data)) {
      return secret ? this.createSecretIntegerUnsigned(data) : this.createPublicIntegerUnsigned(data);
    } else if (isNumber(data)) {
      return secret ? this.createSecretInteger(data) : this.createPublicInteger(data);
    } else {
      throw new Error(
        "Invalid NadaValue.fromPrimitive() arguments: " + JSON.stringify(args)
      );
    }
  }
  static createSecretString(data) {
    return new _NadaValue(
      NadaValueType.enum.SecretString,
      SecretString.parse(data)
    );
  }
  static createSecretBlob(data) {
    return new _NadaValue(NadaValueType.enum.SecretBlob, SecretBlob.parse(data));
  }
  static createPublicInteger(data) {
    return new _NadaValue(
      NadaValueType.enum.PublicInteger,
      PublicInteger.parse(data)
    );
  }
  static createSecretInteger(data) {
    return new _NadaValue(
      NadaValueType.enum.SecretInteger,
      SecretInteger.parse(data)
    );
  }
  static createPublicIntegerUnsigned(data) {
    return new _NadaValue(
      NadaValueType.enum.PublicIntegerUnsigned,
      PublicIntegerUnsigned.parse(data)
    );
  }
  static createSecretIntegerUnsigned(data) {
    return new _NadaValue(
      NadaValueType.enum.SecretIntegerUnsigned,
      SecretIntegerUnsigned.parse(data)
    );
  }
};

// ../client-core/src/nada/values.ts
import * as Wasm5 from "@nillion/client-wasm";
var NadaValues2 = class _NadaValues {
  constructor(values = /* @__PURE__ */ new Map()) {
    this.values = values;
  }
  get length() {
    return this.values.size;
  }
  insert(name, value) {
    Log(`Inserting into NadaValues ${name}=`, value);
    if (this.values.get(name)) {
      Log(`Insertion overwrote: ${name}`);
    }
    this.values.set(name, value);
    return this;
  }
  toString() {
    const values = Array.from(this.values);
    const stringified = values.map(([key, value]) => `${key}=${value.toString()}`).join(",");
    return `NadaValues([${stringified}])`;
  }
  into() {
    const wasmValues = new Wasm5.NadaValues();
    for (const [key, value] of this.values) {
      const wasmValue = value.toWasm();
      wasmValues.insert(key, wasmValue);
    }
    return wasmValues;
  }
  static create() {
    return new _NadaValues();
  }
};

// ../client-core/src/operation/compute.ts
import * as Wasm9 from "@nillion/client-wasm";

// ../client-core/src/operation/operation.ts
import { z as z4 } from "zod";

// ../client-core/src/operation/program.ts
import * as Wasm6 from "@nillion/client-wasm";
var StoreProgram = class {
  constructor(args) {
    this.args = args;
  }
  type = OperationType.enum.StoreProgram;
  intoQuotable() {
    return Wasm6.Operation.store_program(this.args.program);
  }
  toString() {
    return `Operation(type="StoreProgram")`;
  }
};

// ../client-core/src/operation/store-acl.ts
import * as Wasm7 from "@nillion/client-wasm";
var SetStoreAcl = class {
  constructor(args) {
    this.args = args;
  }
  type = OperationType.enum.SetStoreAcl;
  intoQuotable() {
    return Wasm7.Operation.update_permissions();
  }
  toString() {
    return `Operation(type="SetStoreAcl")`;
  }
};
var FetchStoreAcl = class {
  constructor(args) {
    this.args = args;
  }
  type = OperationType.enum.FetchStoreAcl;
  intoQuotable() {
    return Wasm7.Operation.retrieve_permissions();
  }
  toString() {
    return `Operation(type="FetchStoreAcl")`;
  }
};

// ../client-core/src/operation/values.ts
import * as Wasm8 from "@nillion/client-wasm";
var FetchValue = class {
  constructor(args) {
    this.args = args;
  }
  type = OperationType.enum.FetchValue;
  intoQuotable() {
    return Wasm8.Operation.retrieve_value();
  }
  toString() {
    return `Operation(type="FetchValue")`;
  }
};
var DeleteValue = class {
  constructor(args) {
    this.args = args;
  }
  type = OperationType.enum.DeleteValue;
  toString() {
    return `Operation(type="DeleteValue")`;
  }
};
var StoreValue = class {
  constructor(args) {
    this.args = args;
  }
  type = OperationType.enum.StoreValue;
  intoQuotable() {
    return Wasm8.Operation.store_values(this.args.values.into(), this.args.ttl);
  }
  toString() {
    return `Operation(type="StoreValue")`;
  }
};
var UpdateValue = class {
  constructor(args) {
    this.args = args;
  }
  type = OperationType.enum.UpdateValue;
  intoQuotable() {
    return Wasm8.Operation.update_values(this.args.values.into(), this.args.ttl);
  }
  toString() {
    return `Operation(type="UpdateValue")`;
  }
};

// ../client-core/src/operation/operation.ts
var OperationType = z4.enum([
  "StoreProgram",
  "Compute",
  "FetchComputeOutput",
  "StoreValue",
  "FetchValue",
  "UpdateValue",
  "DeleteValue",
  "FetchStoreAcl",
  "SetStoreAcl"
]);
var Operation7 = {
  storeProgram: (args) => new StoreProgram(args),
  compute: (args) => new Compute(args),
  fetchComputeOutput: (args) => new FetchComputeOutput(args),
  storeValues: (args) => new StoreValue(args),
  fetchValue: (args) => new FetchValue(args),
  updateValues: (args) => new UpdateValue(args),
  deleteValues: (args) => new DeleteValue(args),
  fetchAcl: (args) => new FetchStoreAcl(args),
  setAcl: (args) => new SetStoreAcl(args)
};

// ../client-core/src/operation/compute.ts
var Compute = class {
  constructor(args) {
    this.args = args;
  }
  type = OperationType.enum.Compute;
  intoQuotable() {
    return Wasm9.Operation.compute(
      this.args.bindings.id,
      this.args.values.into()
    );
  }
  toString() {
    return `Operation(type="Compute")`;
  }
};
var FetchComputeOutput = class {
  constructor(args) {
    this.args = args;
  }
  type = OperationType.enum.FetchComputeOutput;
  toString() {
    return `Operation(type="FetchComputeOutput")`;
  }
};

// ../client-core/src/result.ts
import { Effect as E, pipe } from "effect";
import { ZodError } from "zod";
var effectToResultAsync = (effect) => {
  return pipe(
    effect,
    E.match({
      onSuccess: (ok) => ({ ok, err: null }),
      onFailure: (err) => unwindError(err)
    }),
    E.runPromise
  );
};
var unwindError = (err) => {
  if (isTaggedError(err)) {
    const root = findRootErrorCause(err);
    if (root instanceof ZodError) {
      console.error("Operation failed with parsing error:", root.message);
      console.error("Stack trace: ", root.stack);
    } else {
      console.error("Operation failed with root error: ", root.message);
      console.error("Stack trace: ", root.stack);
    }
    return { err: root, ok: null };
  }
  console.error(err);
  throw err;
};
var findRootErrorCause = (err) => {
  const { cause } = err;
  if (!(cause instanceof Error)) {
    return err;
  } else {
    return findRootErrorCause(cause);
  }
};

// ../client-core/src/wasm.ts
import * as Wasm10 from "@nillion/client-wasm";
var priceQuoteFrom = (wasm) => {
  return PriceQuote.parse({
    expires: wasm.expires_at,
    nonce: wasm.nonce,
    cost: OperationCost.parse({
      base: Number(wasm.cost.base_fee),
      compute: Number(wasm.cost.compute_fee),
      congestion: Number(wasm.cost.congestion_fee),
      preprocessing: Number(wasm.cost.preprocessing_fee),
      storage: Number(wasm.cost.storage_fee),
      total: Number(wasm.cost.total)
    }),
    inner: wasm
  });
};
var paymentReceiptInto = (receipt) => new Wasm10.PaymentReceipt(receipt.quote.inner, receipt.hash);

// ../client-payments/src/client.ts
import { create as create2 } from "@bufbuild/protobuf";
import { Registry } from "@cosmjs/proto-signing";
import {
  GasPrice,
  SigningStargateClient
} from "@cosmjs/stargate";
import { Effect as E2 } from "effect";

// ../client-payments/src/errors.ts
var AccountNotFoundError = class extends Error {
  _tag = "AccountNotFoundError";
  constructor(account, cause) {
    const message = `Account ${account} not found or it has no funds.`;
    super(message, { cause });
    this.name = "AccountNotFoundError";
  }
};
var UnknownPaymentError = class extends Error {
  _tag = "UnknownPaymentError";
  constructor(cause) {
    super("UnknownPaymentError", { cause });
    this.name = "UnknownPaymentError";
  }
};

// ../client-payments/src/gen-proto/nillion/meta/v1/msg_pay_for_pb.ts
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
var file_nillion_meta_v1_msg_pay_for = /* @__PURE__ */ fileDesc("CiFuaWxsaW9uL21ldGEvdjEvbXNnX3BheV9mb3IucHJvdG8SD25pbGxpb24ubWV0YS52MSJcCglNc2dQYXlGb3ISEAoIcmVzb3VyY2UYASABKAwSFAoMZnJvbV9hZGRyZXNzGAIgASgJEicKBmFtb3VudBgDIAMoCzIXLm5pbGxpb24ubWV0YS52MS5BbW91bnQiJwoGQW1vdW50Eg0KBWRlbm9tGAEgASgJEg4KBmFtb3VudBgCIAEoCUKDAQoTY29tLm5pbGxpb24ubWV0YS52MUIOTXNnUGF5Rm9yUHJvdG9QAaICA05NWKoCD05pbGxpb24uTWV0YS5WMcoCD05pbGxpb25cTWV0YVxWMeICG05pbGxpb25cTWV0YVxWMVxHUEJNZXRhZGF0YeoCEU5pbGxpb246Ok1ldGE6OlYxYgZwcm90bzM");
var MsgPayForSchema = /* @__PURE__ */ messageDesc(file_nillion_meta_v1_msg_pay_for, 0);

// ../client-payments/src/grpc-compat.ts
import { create } from "@bufbuild/protobuf";
import { BinaryWriter } from "@bufbuild/protobuf/wire";
var MsgPayForCompatWrapper = {
  // @ts-expect-error see MsgPayForCompatWrapper comment
  encode: (message, writer = new BinaryWriter()) => {
    if (message.resource.length > 0) {
      writer.uint32(10).bytes(message.resource);
    }
    if (message.fromAddress !== "") {
      writer.uint32(18).string(message.fromAddress);
    }
    for (const amount of message.amount) {
      const amountWriter = new BinaryWriter();
      if (amount.denom !== "") {
        amountWriter.uint32(10).string(amount.denom);
      }
      if (amount.amount !== "") {
        amountWriter.uint32(18).string(amount.amount);
      }
      writer.uint32(26).bytes(amountWriter.finish());
    }
    return writer;
  },
  // @ts-expect-error see MsgPayForCompatWrapper comment
  decode: (_input, _length) => {
    throw new Error("MsgPayForCompatWrapper: decode not implemented");
  },
  fromPartial: (object) => {
    return create(MsgPayForSchema, {
      resource: object.resource,
      fromAddress: object.fromAddress,
      amount: object.amount
    });
  }
};

// ../client-payments/src/logger.ts
import debug2 from "debug";
var Log2 = debug2("nillion:payments");
Log2.log = console.log.bind(console);

// ../client-payments/src/types.ts
import { z as z5 } from "zod";
var PaymentClientConfig = z5.object({
  chainId: ChainId,
  endpoint: Url,
  signer: z5.custom().optional()
});
var NilChainProtobufTypeUrl = "/nillion.meta.v1.MsgPayFor";

// ../client-payments/src/wallet.ts
import { DirectSecp256k1Wallet } from "@cosmjs/proto-signing";
var getKeplr = async () => {
  if (window.keplr) {
    return window.keplr;
  }
  if (document.readyState === "complete") {
    return window.keplr;
  }
  return new Promise((resolve) => {
    const documentStateChange = (event) => {
      if (event.target && event.target.readyState === "complete") {
        resolve(window.keplr);
        document.removeEventListener("readystatechange", documentStateChange);
      }
    };
    document.addEventListener("readystatechange", documentStateChange);
  });
};

// ../client-payments/src/client.ts
var PaymentsClient = class _PaymentsClient {
  constructor(_config) {
    this._config = _config;
  }
  _client = void 0;
  _address = void 0;
  _signer = void 0;
  get ready() {
    return Boolean(this._client) && Boolean(this._address) && Boolean(this._signer);
  }
  get client() {
    this.isReadyGuard();
    return this._client;
  }
  get signer() {
    this.isReadyGuard();
    return this._signer;
  }
  get address() {
    this.isReadyGuard();
    return this._address;
  }
  isReadyGuard() {
    if (!this.ready) {
      const message = "NilChainPaymentClient not ready. Call `await client.connect()`.";
      Log2(message);
      throw new Error(message);
    }
  }
  async connect() {
    const { endpoint, chainId } = this._config;
    const registry = new Registry();
    registry.register(NilChainProtobufTypeUrl, MsgPayForCompatWrapper);
    this._signer = this._config.signer;
    if (!this._signer) {
      const keplr = await getKeplr();
      if (keplr) {
        await keplr.enable(chainId);
        this._signer = keplr.getOfflineSigner(chainId);
      } else {
        throw new Error("No signer provided and keplr not found.");
      }
    }
    const accounts = await this._signer.getAccounts();
    if (!accounts[0]) {
      throw new Error("No accounts found for provided signer.");
    }
    this._address = NilChainAddress.parse(accounts[0].address);
    const options = {
      gasPrice: GasPrice.fromString(Token.asUnil(0)),
      registry
    };
    this._client = await SigningStargateClient.connectWithSigner(
      endpoint,
      this._signer,
      options
    );
    Log2("Connected to chain using address %s", this._address);
    return this.ready;
  }
  pay(quote) {
    return E2.Do.pipe(
      E2.let(
        "transferMessage",
        () => create2(MsgPayForSchema, {
          fromAddress: this.address,
          resource: quote.nonce,
          amount: [{ denom: Token.Unil, amount: String(quote.cost.total) }]
        })
      ),
      E2.flatMap(
        ({ transferMessage }) => E2.tryPromise(
          () => this.client.signAndBroadcast(
            this.address,
            [{ typeUrl: NilChainProtobufTypeUrl, value: transferMessage }],
            "auto"
          )
        )
      ),
      E2.map((result) => {
        const hash = TxHash.parse(result.transactionHash);
        Log2("Paid %d unil, tx hash %s", quote.cost.total, hash);
        return hash;
      }),
      E2.mapError((e) => {
        const cause = e.cause;
        if (cause instanceof Error) {
          const message = cause.message;
          if (message.includes("does not exist on chain")) {
            Log2("Payment failed because account not found %s.", this.address);
            return new AccountNotFoundError(this.address, cause);
          }
        }
        Log2("Payment failed unknown error %O.", e);
        return new UnknownPaymentError(e);
      })
    );
  }
  static create = (config) => new _PaymentsClient(config);
};

// src/logger.ts
import debug3 from "debug";
var Log3 = debug3("nillion:vms");
Log3.log = console.log.bind(console);

// src/nada.ts
import { Effect as E3 } from "effect";
var toNadaValues = (args) => E3.try(() => {
  const nadaValues = NadaValues2.create();
  const name = NamedValue.parse(args.name, {
    path: ["toNadaValues", "NamedValue"]
  });
  const nadaValueArgs = isObjectLiteral(args.value) ? args.value : {
    secret: true,
    data: args.value
  };
  const nadaValue = NadaValue2.fromPrimitive(nadaValueArgs);
  nadaValues.insert(name, nadaValue);
  return nadaValues;
});

// src/nilvm/client.ts
import { Effect as E4 } from "effect";
import { z as z6 } from "zod";
import * as Wasm11 from "@nillion/client-wasm";
var NilVmClientConfig = z6.object({
  bootnodes: z6.array(Multiaddr),
  clusterId: ClusterId,
  userSeed: z6.string(),
  nodeSeed: z6.string()
});
var NilVmClient = class _NilVmClient {
  constructor(_config) {
    this._config = _config;
  }
  // The wasm bundle is loaded asynchronously which can be problematic because most environments don't
  // support top-level awaits. To manage this complexity `this._client` is lazily initialized and guarded
  // by `isReadyGuard`. Users can therefore create the client in one place and then connect when they are
  // inside an async context.
  // @ts-expect-error lazily loaded on `connect()`, wrapped by `isReadyGuard()` and public access via getter
  _client;
  _ready = false;
  get ready() {
    return this._ready;
  }
  get partyId() {
    this.isReadyGuard();
    return PartyId.parse(this._client.party_id);
  }
  get userId() {
    this.isReadyGuard();
    return UserId.parse(this._client.user_id);
  }
  get clusterId() {
    return this._config.clusterId;
  }
  get client() {
    this.isReadyGuard();
    return this._client;
  }
  async connect() {
    if (!globalThis.__NILLION?.initialized) {
      await init();
    }
    const { clusterId, userSeed, nodeSeed, bootnodes } = this._config;
    const userKey = Wasm11.UserKey.from_seed(userSeed);
    const nodeKey = Wasm11.NodeKey.from_seed(nodeSeed);
    this._client = new Wasm11.NillionClient(userKey, nodeKey, bootnodes);
    const descriptor = await this._client.cluster_information(clusterId);
    this._ready = true;
    Log3("Connected to cluster: ", descriptor.id);
    return this._ready;
  }
  isReadyGuard() {
    if (!this._ready) {
      const message = "NilVmClient not ready. Call `await client.connect()`.";
      Log3(message);
      throw new Error(message);
    }
  }
  fetchClusterInfo() {
    return E4.tryPromise(async () => {
      const response = await this.client.cluster_information(this.clusterId);
      const descriptor = ClusterDescriptor.parse(response);
      Log3("Fetched cluster info: %O", descriptor);
      return descriptor;
    });
  }
  fetchComputeOutput(args) {
    return E4.tryPromise(async () => {
      const { id } = args;
      const response = await this.client.compute_result(id);
      Log3(`Retrieved ${id} result:`, response);
      return response;
    });
  }
  fetchOperationQuote(args) {
    return E4.tryPromise(async () => {
      const { operation } = args;
      const response = await this.client.request_price_quote(
        this.clusterId,
        operation.intoQuotable()
      );
      const result = priceQuoteFrom(response);
      Log3(`Quoted %d unil for %s`, result.cost.total, operation.type);
      return result;
    });
  }
  fetchValue(args) {
    return E4.tryPromise(async () => {
      const { receipt, operation } = args;
      const { id, name, type } = operation.args;
      const wasmReceipt = paymentReceiptInto(receipt);
      const response = await this.client.retrieve_value(
        this.clusterId,
        id,
        name,
        wasmReceipt
      );
      wasmReceipt.free();
      receipt.quote.inner.free();
      const result = NadaValue2.fromWasm(type, response);
      Log3(`Fetched ${type} from ${id}`);
      return result;
    });
  }
  fetchStoreAcl(args) {
    return E4.tryPromise(async () => {
      const { receipt, operation } = args;
      const { id } = operation.args;
      const wasmReceipt = paymentReceiptInto(receipt);
      const response = await this.client.retrieve_permissions(
        this.clusterId,
        id,
        wasmReceipt
      );
      wasmReceipt.free();
      receipt.quote.inner.free();
      const result = StoreAcl.from(response);
      Log3(`Fetched acl for store ${id}. Acl=%O`, result);
      return result;
    });
  }
  setStoreAcl(args) {
    return E4.tryPromise(async () => {
      const { receipt, operation } = args;
      const { id, acl } = operation.args;
      const wasmReceipt = paymentReceiptInto(receipt);
      const wasmPermissions = acl.into();
      const response = await this.client.update_permissions(
        this.clusterId,
        id,
        wasmPermissions,
        wasmReceipt
      );
      wasmReceipt.free();
      receipt.quote.inner.free();
      const result = ActionId.parse(response);
      Log3(`Set store Acl for ${id} to Acl=%O`, acl);
      return result;
    });
  }
  compute(args) {
    return E4.tryPromise(async () => {
      const { receipt, operation } = args;
      const { bindings, storeIds, values } = operation.args;
      const wasmValues = values.into();
      const wasmReceipt = paymentReceiptInto(receipt);
      const response = await this.client.compute(
        this.clusterId,
        bindings.into(),
        storeIds,
        wasmValues,
        wasmReceipt
      );
      wasmValues.free();
      wasmReceipt.free();
      receipt.quote.inner.free();
      const result = ComputeOutputId.parse(response);
      Log3(`Compute started resultId=${result}`);
      return result;
    });
  }
  storeProgram(args) {
    return E4.tryPromise(async () => {
      const { receipt, operation } = args;
      const { name, program } = operation.args;
      const wasmReceipt = paymentReceiptInto(receipt);
      const response = await this.client.store_program(
        this.clusterId,
        name,
        program,
        wasmReceipt
      );
      wasmReceipt.free();
      receipt.quote.inner.free();
      const id = ProgramId.parse(response);
      Log3(`program stored with id=${id}`);
      return id;
    });
  }
  deleteValues(args) {
    return E4.tryPromise(async () => {
      const { id } = args;
      await this.client.delete_values(this.clusterId, id);
      Log3(`Deleted values at ${id}`);
      return id;
    });
  }
  updateValues(args) {
    return E4.tryPromise(async () => {
      const { receipt, operation } = args;
      const { id, values } = operation.args;
      const wasmValues = values.into();
      const wasmReceipt = paymentReceiptInto(receipt);
      const response = await this.client.update_values(
        this.clusterId,
        id,
        wasmValues,
        wasmReceipt
      );
      wasmValues.free();
      wasmReceipt.free();
      receipt.quote.inner.free();
      Log3(`Updated values at ${id}`);
      return ActionId.parse(response);
    });
  }
  storeValues(args) {
    return E4.tryPromise(async () => {
      const { receipt, operation } = args;
      const { values, acl } = operation.args;
      const wasmValues = values.into();
      const wasmReceipt = paymentReceiptInto(receipt);
      const wasmPermissions = acl?.into();
      const response = await this.client.store_values(
        this.clusterId,
        wasmValues,
        wasmPermissions,
        wasmReceipt
      );
      wasmValues.free();
      wasmReceipt.free();
      receipt.quote.inner.free();
      Log3(`Stored values ${values.toString()} at ${response}`);
      return StoreId.parse(response);
    });
  }
  static create = (args) => new _NilVmClient(args);
};

// src/types.ts
import { z as z7 } from "zod";
var NetworkConfig = z7.object({
  bootnodes: z7.array(Multiaddr),
  clusterId: ClusterId,
  nilChainId: ChainId,
  nilChainEndpoint: Url
});
var UserCredentials = z7.object({
  userSeed: UserSeed,
  nodeSeed: NodeSeed.default(() => window.crypto.randomUUID()),
  signer: z7.union([
    z7.literal("keplr"),
    z7.function().returns(z7.custom().promise())
  ])
});

// src/client.ts
var NillionClient3 = class _NillionClient {
  _vm;
  _chain;
  _userConfig;
  _networkConfig;
  /**
   * The constructor is private to enforce use of {@link NillionClient.create}.
   */
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  constructor() {
  }
  /**
   * If the client is ready to execute operations.
   *
   * @returns true if both the VM and Payments clients are ready; otherwise, false.
   */
  get ready() {
    return Boolean(this._userConfig && this._vm?.ready && this._chain?.ready);
  }
  /**
   * Guarded access to the vm client.
   *
   * @throws Error if the client is not ready.
   * @returns The initialized {@link NilVmClient} instance.
   */
  get vm() {
    this.isReadyGuard();
    return this._vm;
  }
  /**
   * Guarded access to the payments' client.
   *
   * @throws Error if the client is not ready.
   * @returns The initialized {@link PaymentsClient} instance.
   */
  get chain() {
    this.isReadyGuard();
    return this._chain;
  }
  /**
   * Set the client's {@link NetworkConfig}.
   *
   * This must be invoked before {@link NillionClient.connect}.
   *
   * @param config - {@link NetworkConfig}
   */
  setNetworkConfig(config) {
    this._networkConfig = NetworkConfig.parse(config);
  }
  /**
   * Get the client's {@link NetworkConfig}.
   *
   */
  get networkConfig() {
    this.isReadyGuard();
    return this._networkConfig;
  }
  setUserCredentials(config) {
    this._userConfig = UserCredentials.parse(config);
  }
  get userConfig() {
    this.isReadyGuard();
    return this._userConfig;
  }
  get userId() {
    return this.vm.userId;
  }
  get partyId() {
    return this.vm.partyId;
  }
  /**
   * This guards against access before initialization. NillionClient creation is sync,
   * but PaymentClient and VmClient instantiation are async.
   *
   * @throws Error with message indicating the client is not ready.
   */
  isReadyGuard() {
    if (!this.ready) {
      const message = "NillionClient not initialiazed.";
      Log3(message);
      throw new Error(message);
    }
  }
  /**
   * Connect parses the provided config, initializes the PaymentsClient and VmClient,
   * and then validates connections by querying the nilchain address and the Network's
   * cluster descriptor.
   *
   * This method must be called before the client is used; subsequent calls are ignored.
   *
   * @returns A promise that resolves to true if the connection is successfully established.
   */
  connect() {
    if (this.ready) {
      Log3("NillionClient is already connected. Ignoring connect().");
      return Promise.resolve(this.ready);
    }
    return pipe2(
      E5.tryPromise(async () => {
        const combined = {
          ...this._userConfig,
          ...this._networkConfig
        };
        Log3("Config: %O", combined);
        const nilVmConfig = NilVmClientConfig.parse({
          bootnodes: combined.bootnodes,
          clusterId: combined.clusterId,
          userSeed: combined.userSeed,
          nodeSeed: combined.nodeSeed
        });
        const signer = typeof combined.signer === "function" ? await combined.signer() : void 0;
        const nilChainConfig = PaymentClientConfig.parse({
          chainId: combined.nilChainId,
          endpoint: combined.nilChainEndpoint,
          signer
        });
        this._vm = NilVmClient.create(nilVmConfig);
        this._chain = PaymentsClient.create(nilChainConfig);
        await this._vm.connect();
        await this._chain.connect();
        Log3("NillionClient connected.");
        return this.ready;
      }),
      E5.mapError((error) => {
        if (error instanceof ZodError2) {
          Log3("Parsing error: %O", error.format());
        } else {
          Log3("Connection failed: %O", error);
        }
      }),
      E5.runPromise
    );
  }
  /**
   * Disconnects the client. This function is a no-op and serves as a placeholder.
   */
  disconnect() {
    this._vm = void 0;
    this._chain = void 0;
    Log3("Client disconnected");
    return Promise.resolve();
  }
  /**
   * Stores values in the network. This function is friendlier than manually
   * composing {@link NadaValues} from {@link NadaValue} because it takes care
   * of converting from a key to primitive values map to Nada types automatically.
   *
   * @example
   * ```ts
   * declare client: NillionClient
   *
   * const id = await client.store({
   *  values: {
   *    foo: 42,
   *    bar: "hello",
   *  },
   *  ttl: 2 // 2 days,
   *  acl: StoreAcl.createDefaultForUser(client.vm.userId),
   * })
   * ```
   *
   * @see NillionClient.storeValues
   * @param args - An object defining values, time-to-live and optional permissions.
   * @returns A promise resolving to the {@link Result} of the store operation.
   */
  async store(args) {
    return E5.Do.pipe(
      E5.bind(
        "values",
        () => toNadaValues({ name: args.name, value: args.value })
      ),
      E5.flatMap(
        ({ values }) => E5.tryPromise(
          () => this.storeValues({
            values,
            ttl: args.ttl,
            acl: args.acl
          })
        )
      ),
      E5.runPromise
    );
  }
  /**
   * Retrieves a named Nada value from the network and de-serializes it as a
   * native JS primitive value. This method is friendlier that NillionClient.fetchValue
   * because it accepts and returns primitive values.
   *
   * @example
   * ```ts
   * declare client: NillionClient
   *
   * const response = await client.fetch({ id, name: "foo", type: "SecretInteger" })
   *
   * if(response.ok) {
   *    const value = response.ok
   * }
   * ```
   *
   * @param args - An object defining the store id, value name and the deserialization type.
   * @returns A promise resolving to the {@link Result} of the fetch operation.
   */
  fetch(args) {
    return E5.Do.pipe(
      E5.bind(
        "id",
        () => E5.try(
          () => StoreId.parse(args.id, { path: ["client.fetch", "args.id"] })
        )
      ),
      E5.bind(
        "name",
        () => E5.try(
          () => NamedValue.parse(args.name, { path: ["client.fetch", "args.name"] })
        )
      ),
      E5.bind(
        "type",
        () => E5.try(
          () => NadaValueType.parse(args.type, {
            path: ["client.fetch", "args.type"]
          })
        )
      ),
      E5.flatMap(
        ({ id, name, type }) => E5.tryPromise(async () => {
          const result = await this.fetchValue({
            id,
            name,
            type
          });
          if (result.err) {
            Log3(
              "Fetch value failed for id=%s name=%s: %O",
              id,
              name,
              result.err
            );
            throw result.err;
          }
          return result.ok.data;
        })
      ),
      effectToResultAsync
    );
  }
  /**
   * Updates values at the given store id. Similar to {@link NillionClient.store}, this
   * function takes care of converting from primitive values to Nada types automatically.
   *
   * @param args - An Object with the store id, values and time-to-live.
   * @returns A promise resolving to the update's unique action id in the network.
   * @see NillionClient.updateValue
   */
  update(args) {
    return E5.Do.pipe(
      E5.bind(
        "id",
        () => E5.try(
          () => StoreId.parse(args.id, { path: ["client.update", "args.id"] })
        )
      ),
      E5.bind(
        "ttl",
        () => E5.try(
          () => Days.parse(args.ttl, { path: ["client.update", "args.ttl"] })
        )
      ),
      E5.bind(
        "values",
        () => toNadaValues({ name: args.name, value: args.value })
      ),
      E5.flatMap((args2) => E5.tryPromise(() => this.updateValue(args2))),
      E5.runPromise
    );
  }
  /**
   * Pay for the operation.
   *
   * Retrieves a quote from the leader, pays for it on nilchian and then returns a {@link PaymentReceipt}.
   *
   * @param args - An object containing the operation and its type.
   * @returns An {@link E.Effect} that resolves to a {@link PaymentReceipt}.
   */
  pay(args) {
    return E5.Do.pipe(
      E5.bind("quote", () => this.vm.fetchOperationQuote(args)),
      E5.bind("hash", ({ quote }) => this.chain.pay(quote)),
      E5.map(
        ({ quote, hash }) => PaymentReceipt.parse(
          {
            quote,
            hash
          },
          { path: ["client.pay", "PaymentReceipt"] }
        )
      ),
      E5.mapError((e) => {
        if (e instanceof UnknownException) return e;
        else return new UnknownException(e);
      })
    );
  }
  /**
   * Invokes the specified program.
   *
   * @param args - An object containing program bindings, run-time values, and ids for values to be retrieved directly from StoreIds.
   * @returns A promise resolving to the {@link ComputeOutputId} which will points to the program's output.
   * @see NillionClient.fetchComputeOutput
   */
  compute(args) {
    return E5.Do.pipe(
      E5.bind(
        "storeIds",
        () => E5.try(
          () => args.storeIds.map(
            (id) => StoreId.parse(id, { path: ["client.compute", "args.ids.id"] })
          )
        )
      ),
      E5.let(
        "operation",
        ({ storeIds }) => Operation7.compute({
          storeIds,
          bindings: args.bindings,
          values: args.values
        })
      ),
      E5.bind("receipt", (args2) => this.pay(args2)),
      E5.flatMap((args2) => this.vm.compute(args2)),
      effectToResultAsync
    );
  }
  /**
   * Fetches the result from a program execution.
   *
   * @param args - An object containing the {@link ComputeOutputId}.
   * @returns A promise resolving to a Map of the program's output.
   * @see NillionClient.compute
   */
  fetchComputeOutput(args) {
    return E5.Do.pipe(
      E5.bind(
        "id",
        () => E5.try(
          () => ComputeOutputId.parse(args.id, {
            path: ["client.fetchComputeOutput", "args.id"]
          })
        )
      ),
      E5.let("operation", ({ id }) => Operation7.fetchComputeOutput({ id })),
      E5.flatMap(({ operation }) => this.vm.fetchComputeOutput(operation.args)),
      effectToResultAsync
    );
  }
  /**
   * Delete the {@link NadaValues} stored at {@link StoreId}.
   *
   * @param args - An object containing the {@link StoreId} to delete.
   * @returns A promise resolving to the deleted {@link StoreId}.
   */
  deleteValues(args) {
    return E5.Do.pipe(
      E5.bind(
        "id",
        () => E5.try(
          () => StoreId.parse(args.id, { path: ["client.deleteValues", "args.id"] })
        )
      ),
      E5.flatMap((args2) => this.vm.deleteValues(args2)),
      effectToResultAsync
    );
  }
  /**
   * Fetch network details.
   *
   * @returns A promise resolving to the network's {@link ClusterDescriptor}.
   */
  fetchClusterInfo() {
    return pipe2(this.vm.fetchClusterInfo(), effectToResultAsync);
  }
  /**
   * Asks the leader to quote the provided operation.
   *
   * @param args - An object containing the {@link Operation}.
   * @returns A promise resolving to the {@link PriceQuote}.
   * @see NillionClient.pay
   */
  fetchOperationQuote(args) {
    return pipe2(this.vm.fetchOperationQuote(args), effectToResultAsync);
  }
  /**
   * Fetch the {@link NamedValue} at {@link StoreId}.
   *
   * @param args - An object containing the {@link StoreId}, {@link NamedValue} and {@link NadaValueType}.
   * @returns A promise resolving to the {@link Result} containing a `Map` where the keys are {@link NamedValue} and the values are {@link NadaValue}.
   */
  fetchValue(args) {
    return E5.Do.pipe(
      E5.bind(
        "id",
        () => E5.try(
          () => StoreId.parse(args.id, { path: ["client.fetchValue", "args.id"] })
        )
      ),
      E5.bind(
        "name",
        () => E5.try(
          () => NamedValue.parse(args.name, {
            path: ["client.fetchValue", "args.name"]
          })
        )
      ),
      E5.let(
        "operation",
        ({ id, name }) => Operation7.fetchValue({
          id,
          name,
          type: args.type
        })
      ),
      E5.bind("receipt", (args2) => this.pay(args2)),
      E5.flatMap((args2) => this.vm.fetchValue(args2)),
      effectToResultAsync
    );
  }
  /**
   * Store a program in the network.
   *
   * @param args - An object containing the {@link ProgramName} and the program as a {@link Uint8Array}.
   * @returns A promise resolving to the {@link Result} containing the {@link ProgramId}.
   */
  storeProgram(args) {
    return E5.Do.pipe(
      E5.bind(
        "name",
        () => E5.try(
          () => ProgramName.parse(args.name, {
            path: ["client.storeProgram", "args.name"]
          })
        )
      ),
      E5.let(
        "operation",
        ({ name }) => Operation7.storeProgram({ name, program: args.program })
      ),
      E5.bind("receipt", ({ operation }) => this.pay({ operation })),
      E5.flatMap((args2) => this.vm.storeProgram(args2)),
      effectToResultAsync
    );
  }
  /**
   * Stores {@link NadaValues} in the network.
   *
   * @param args - An object containing the values, time-to-live, and optional permissions.
   * @returns A promise resolving to the {@link Result} containing the store id.
   */
  storeValues(args) {
    return E5.Do.pipe(
      E5.bind(
        "ttl",
        () => E5.try(
          () => Days.parse(args.ttl, {
            path: ["client.storeValues", "args.ttl"]
          })
        )
      ),
      E5.let(
        "operation",
        ({ ttl }) => Operation7.storeValues({
          values: args.values,
          ttl,
          acl: args.acl
        })
      ),
      E5.bind("receipt", (args2) => this.pay(args2)),
      E5.flatMap((args2) => this.vm.storeValues(args2)),
      effectToResultAsync
    );
  }
  /**
   * Updates the store id location with the provided values.
   *
   * @param args - An object containing the store id to update with updated values and time-to-live.
   * @returns A promise resolving to the {@link Result} containing the {@link ActionId}.
   */
  updateValue(args) {
    return E5.Do.pipe(
      E5.let("operation", () => Operation7.updateValues(args)),
      E5.bind("receipt", (args2) => this.pay(args2)),
      E5.flatMap((args2) => this.vm.updateValues(args2)),
      effectToResultAsync
    );
  }
  /**
   * Fetches a store id's permissions.
   *
   * @param args - An object containing the {@link StoreId}.
   * @returns A promise resolving to the {@link Result} containing the {@link StoreAcl}.
   */
  fetchStoreAcl(args) {
    return E5.Do.pipe(
      E5.bind(
        "id",
        () => E5.try(
          () => StoreId.parse(args.id, {
            path: ["client.fetchStoreAcl", "args.id"]
          })
        )
      ),
      E5.let("operation", ({ id }) => Operation7.fetchAcl({ id })),
      E5.bind("receipt", ({ operation }) => this.pay({ operation })),
      E5.flatMap(
        ({ operation, receipt }) => this.vm.fetchStoreAcl({ operation, receipt })
      ),
      effectToResultAsync
    );
  }
  /**
   * Sets the access control list for a stored value.
   *
   * The existing Acl is overwritten.
   *
   * @param args - An object containing the {@link StoreId} and the new {@link StoreAcl}.
   * @returns A promise resolving to the {@link Result} containing the {@link ActionId}.
   */
  setStoreAcl(args) {
    return E5.Do.pipe(
      E5.bind(
        "id",
        () => E5.try(
          () => StoreId.parse(args.id, { path: ["setStoreAcl", "args.id"] })
        )
      ),
      E5.let("operation", ({ id }) => Operation7.setAcl({ id, acl: args.acl })),
      E5.bind("receipt", (args2) => this.pay(args2)),
      E5.flatMap((args2) => this.vm.setStoreAcl(args2)),
      effectToResultAsync
    );
  }
  /**
   * Create a {@link NillionClient}.
   *
   * This factory initializes a `NillionClient` ready to accept network and user configs.
   *
   * @returns An unconfigured instance of `NillionClient`.
   * @see NillionClient.setNetworkConfig
   * @see NillionClient.setUserCredentials
   * @see NillionClient.connect
   */
  static create = () => {
    return new _NillionClient();
  };
};
export {
  NadaValue2 as NadaValue,
  NadaValues2 as NadaValues,
  NamedValue,
  NetworkConfig,
  NilVmClient,
  NilVmClientConfig,
  NillionClient3 as NillionClient,
  PrivateKeyBase16,
  StoreId,
  UserCredentials,
  toNadaValues
};
